# Import Block
import os
import numpy as np
from rdkit import Chem
from openff.toolkit.topology import Molecule,Topology
from openff.toolkit.utils import RDKitToolkitWrapper
import openmm
from simtk.openmm import app
from openmm import unit
from openmm.app import PDBFile
import pdb
from openff.toolkit.typing.engines.smirnoff import ForceField
import mdtraj
import warnings
import logging
import pandas as pd
from scipy.optimize import minimize, basinhopping
import csv
from pyxtal.operations import angle, create_matrix
from pyxtal.constants import deg, rad, ltype_keywords
import matplotlib.pyplot as plt

# Functions to minimize energy with respect to box vectors
# forces provide 3*n derivatives of energy
# wrt position, +6 more derivatives of energy wrt box vectors
# def convert_fractional_coordinate():


def matrix2para(matrix, radians=False):
    """
    Given a 3x3 matrix representing a unit cell, outputs a list of lattice
    parameters.
    Args:
        matrix: a 3x3 array or list, where the first, second, and third rows
            represent the a, b, and c vectors respectively
        radians: if True, outputs angles in radians. If False, outputs in
            degrees
    Returns:
        a 1x6 list of lattice parameters [a, b, c, alpha, beta, gamma]. a, b,
        and c are the length of the lattice vectos, and alpha, beta, and gamma
        are the angles between these vectors (in radians by default)
    """
    cell_para = np.zeros(6)
    # a
    cell_para[0] = np.linalg.norm(matrix[0])
    # b
    cell_para[1] = np.linalg.norm(matrix[1])
    # c
    cell_para[2] = np.linalg.norm(matrix[2])
    # alpha
    cell_para[3] = angle(matrix[1], matrix[2])
    # beta
    cell_para[4] = angle(matrix[0], matrix[2])
    # gamma
    cell_para[5] = angle(matrix[0], matrix[1])

    if not radians:
        # convert radians to degrees
        deg = 180.0 / np.pi
        cell_para[3] *= deg
        cell_para[4] *= deg
        cell_para[5] *= deg
    return cell_para

def para2matrix(cell_para, radians=False, format="lower"):
    """
    Given a set of lattic parameters, generates a matrix representing the
    lattice vectors
    Args:
        cell_para: a 1x6 list of lattice parameters [a, b, c, alpha, beta,
            gamma]. a, b, and c are the length of the lattice vectos, and
            alpha, beta, and gamma are the angles between these vectors. Can
            be generated by matrix2para
        radians: if True, lattice parameters should be in radians. If False,
            lattice angles should be in degrees
        format: a string ('lower', 'symmetric', or 'upper') for the type of
            matrix to be output
    Returns:
        a 3x3 matrix representing the unit cell. By default (format='lower'),
        the a vector is aligined along the x-axis, and the b vector is in the
        y-z plane
    """
    a = cell_para[0]
    b = cell_para[1]
    c = cell_para[2]
    alpha = cell_para[3]
    beta = cell_para[4]
    gamma = cell_para[5]
    if radians is not True:
        alpha *= rad
        beta *= rad
        gamma *= rad
    cos_alpha = np.cos(alpha)
    cos_beta = np.cos(beta)
    cos_gamma = np.cos(gamma)
    sin_gamma = np.sin(gamma)
    sin_alpha = np.sin(alpha)
    matrix = np.zeros([3, 3])
    if format == "lower":
        # Generate a lower-diagonal matrix
        c1 = c * cos_beta
        c2 = (c * (cos_alpha - (cos_beta * cos_gamma))) / sin_gamma
        matrix[0][0] = a
        matrix[1][0] = b * cos_gamma
        matrix[1][1] = b * sin_gamma
        matrix[2][0] = c1
        matrix[2][1] = c2
        matrix[2][2] = np.sqrt(c ** 2 - c1 ** 2 - c2 ** 2)
    elif format == "symmetric":
        # TODO: allow generation of symmetric matrices
        pass
    elif format == "upper":
        # Generate an upper-diagonal matrix
        a3 = a * cos_beta
        a2 = (a * (cos_gamma - (cos_beta * cos_alpha))) / sin_alpha
        matrix[2][2] = c
        matrix[1][2] = b * cos_alpha
        matrix[1][1] = b * sin_alpha
        matrix[0][2] = a3
        matrix[0][1] = a2
        tmp = a ** 2 - a3 ** 2 - a2 ** 2
        if tmp > 0:
            matrix[0][0] = np.sqrt(a ** 2 - a3 ** 2 - a2 ** 2)
        else:
            return None
        #pass
    return matrix


def box_energy(x,*args):
    # x is np array of 3*n(atoms) positional coordinates and 6 triclinical box parameters
    # Return the energy of the system (in kJ/mol)
    # *args will have the simulation context and n (number of particles)
    context = args[0]
    n = args[1]
    # Build position array
    positions_arr = np.empty([n,3])
    for i in range(int(n)):
        positions_arr[i][0] = x[i*3]
        positions_arr[i][1] = x[i*3+1]
        positions_arr[i][2] = x[i*3+2]
    box_parameter = [x[n*3], x[n*3+1], x[n*3+2], x[n*3+3], x[n*3+4], x[n*3+5]]
    # convert box parameter to box vector
    box_vector = para2matrix(box_parameter, radians=False, format="lower")
    # Build periodic box vectors
    a = np.array([box_vector[0][0],0,0])
    b = np.array([box_vector[1][0],box_vector[1][1],0])
    c = np.array([box_vector[2][0],box_vector[2][1],box_vector[2][2]])
    '''
    print("-------------------")
    print("periodic box vectors")
    print(a)
    print(b)
    print(c)
    '''
    # Set Context with positions and periodic boundary conditions
    context.setPositions(positions_arr)
    context.setPeriodicBoxVectors(a,b,c)
    # Return Energy
    energy = context.getState(getEnergy=True).getPotentialEnergy().value_in_unit(unit.kilojoule_per_mole)
    return energy

grad_temp_func = []

def jacobian(x,*args):
    # x is np array of 3*n(atoms) positional coordinates and 6 triclinical box parameters
    #must return a n*3 + 6 box parameters with derivative of energy with respect to each input parameter
    #for positions, return given forces
    context = args[0]
    n = args[1]

    energy = context.getState(getEnergy=True).getPotentialEnergy().value_in_unit(unit.kilojoule_per_mole)
    forces = -1*context.getState(getForces=True).getForces(asNumpy=True).value_in_unit(unit.kilojoule_per_mole/(unit.nano*unit.meter))
    jac = forces.flatten()
    # Positions
    positions_arr = np.empty([n,3])
    for i in range(int(n)):
        positions_arr[i][:] = x[i*3:i*3+3]
    context.setPositions(positions_arr)

    # convert box parameter to box vector for atom fractional position
    box_parameter = [x[n * 3], x[n * 3 + 1], x[n * 3 + 2], x[n * 3 + 3], x[n * 3 + 4], x[n * 3 + 5]]
    box_vectors = para2matrix(box_parameter, radians=False, format="lower")
    frac_positions = np.matmul(np.linalg.inv(box_vectors), positions_arr.T).T

    # A, B, C, alpha, beta, gamma
    for i in range(len(box_parameter)):
        # use different epsilon for A, B, C and alpha, beta, gamma
        if i < 3:
            epsilon = 1e-4
        else:
            epsilon = 1e-6

        temp_U = x[n * 3 + i] + epsilon * x[n * 3 + i]
        temp_L = x[n * 3 + i] - epsilon * x[n * 3 + i]
        dstep = temp_U - temp_L
        temp_box_parameters = np.array([x[n * 3], x[n * 3 + 1], x[n * 3 + 2], x[n * 3 + 3], x[n * 3 + 4], x[n * 3 + 5]])
        temp_box_parameters[i] = temp_U # Replace appropriate entry in box parameter
        temp_box_vectors = para2matrix(temp_box_parameters, radians=False, format="lower") # convert box parameter to box vector for atom fractional position
        new_positions = np.matmul(temp_box_vectors, frac_positions.T).T # Transform frac coordiantes with new box vectors
        temp_x = np.concatenate((new_positions.flatten(), temp_box_parameters.flatten()))
        new_energy = box_energy(temp_x, context, n)  # compute new energy
        grad_temp = (new_energy - energy) / dstep # compute gradient
        jac = np.append(jac, grad_temp)  # append to jac

        # grad_temp vs iteration
        grad_temp_func.append(grad_temp)
        plt.plot(grad_temp_func)
        plt.ylabel('grad_temp_func', fontsize=14)
        plt.xlabel('iteration', fontsize=14)
        plt.title('grad_temp vs iteration', fontsize=15)
        plt.ylim(-10000, 10000)
        plt.show()

    #print("new_energy", new_energy)
    #print("grad_temp", grad_temp)

    return jac


# Warning and Logger Setup
warnings.simplefilter("ignore")
logging.basicConfig(filename='errors.log', filemode='w')

# Wrapper and FF setup
# Use RDKit wrapper
rdktkw = RDKitToolkitWrapper()

# Loading setup parameters
forcefield = ForceField('openff-2.0.0.offxml')
# Load smiles csv file as pandas
smiles = pd.read_csv('allcod.smi', names=['SMILES', 'COD ID'], sep='\t')
# Initialize text file for rmsd values to be recorded
with open('data/rmsd_values.txt','w') as f:
    f.write('COD ID\tRMSD\n')
# Initialize empty array to store data from sucessful minimizations
data = []
for pdb in os.listdir('data/PDB'):
    # load pdb with one copy of pdb file
    cod_id = pdb.split('.')[0]
    print(cod_id)
#there is try here
    try:
        # get smiles from all_smilies
        smiles_string = smiles.loc[smiles['COD ID'] == int(cod_id)]['SMILES'].values[0]
        off_mol = Molecule.from_pdb_and_smiles('data/PDB/' + pdb, smiles_string)
    except Exception as e:
        logging.error('PDB/SMILES error with ID %s' % cod_id)
        logging.error(e)
        continue
    try:
        # load supercell pdb file (2x2x2) into topology
        # replace cod_id to
        pdb_file = PDBFile('data/PDB_supercell/' + "2100147" + '_supercell.pdb')
        off_top = Topology.from_openmm(pdb_file.topology, [off_mol])
    except Exception as e:
        logging.error('Topology error with ID %s' % cod_id)
        logging.error(e)
        continue
    # Create MD simulation inputs
    system = forcefield.create_openmm_system(off_top)
    integrator = openmm.VerletIntegrator(1 * unit.femtoseconds)
    platform = openmm.Platform.getPlatformByName('Reference')

    try:
        # create simulation, catch errors
        simulation = openmm.app.Simulation(pdb_file.topology, system, integrator, platform)
    except Exception as e:
        logging.error('Simulation Build error with ID %s' % cod_id)
        logging.error(e)
        continue
    # set initial positions from pdbfile
    positions = pdb_file.getPositions()
    simulation.context.setPositions(positions)

    # set reporters
    pdb_reporter = openmm.app.PDBReporter('data/minimized_PDB_supercell/' + cod_id + '.pdb', 1)
    simulation.reporters.append(pdb_reporter)
    # set positions
    simulation.context.setPositions(positions)
    # save state and print initial PE
    simulation.saveState('data/initial_states/' + cod_id + '_initial.xml')
    orig_potential = simulation.context.getState(getEnergy=True).getPotentialEnergy()
    if orig_potential.value_in_unit(unit.kilojoule_per_mole) > 1e24:
        # Skip if the initial energy evaluation is infeasibly high
        continue
    print('Initial Energy ' + str(orig_potential))
    # Minimize Energy and save final state
    print('Minimizing Energy!')
    simulation.minimizeEnergy(maxIterations=100000)  # Perform initial minimization with openMM minimizer
    mid_potential = simulation.context.getState(getEnergy=True).getPotentialEnergy()
    # # build x array to feed to minimizer
    box_vectors = pdb_file.topology.getPeriodicBoxVectors()
    A = np.array(box_vectors.value_in_unit(unit.nano * unit.meter))
    numpy_positions = simulation.context.getState(getPositions=True).getPositions(asNumpy=True)
    print("Initial box vector\n", A)
    # convert box vector to box parameter
    box_parameter = matrix2para(A, radians=False)
    print("Initial box parameter\n", box_parameter)
    x = np.append(numpy_positions.flatten(), [box_parameter[0], box_parameter[1], box_parameter[2], box_parameter[3], box_parameter[4], box_parameter[5]])
    n = len(numpy_positions)
    '''
    cons = [{'type': 'ineq', 'fun': lambda x: x[n * 3] - 2 * x[n * 3 + 1]},
            {'type': 'ineq', 'fun': lambda x: x[n * 3] - 2 * x[n * 3 + 3]},
            {'type': 'ineq', 'fun': lambda x: x[n * 3 + 2] - 2 * x[n * 3 + 4]}]
    constraints = cons
    '''

    '''
    loss_func = []
    def callback(x):
        fobj = box_energy(x,simulation.context, n)
        loss_func.append(fobj)
        iteration = [i for i in range(len(loss_func))]
        plt.plot(iteration, loss_func)
        plt.ylabel('loss_func', fontsize=14)
        plt.xlabel('iteration', fontsize=14)
        plt.title('loss_func vs iteration', fontsize=15)
        plt.show()
        callback=callback,
    '''

    '''
    bounds = []
    # atom position no limit
    for i in range(n * 3):
        bounds.append((None, None))
    # box parameter > 0
    for i in range(len(box_parameter)):
        bounds.append((0, None))
    bounds=bounds
    '''

    # run minimizer
    result = minimize(box_energy, x, (simulation.context, n), method='L-BFGS-B', jac=jacobian, options={'maxiter': 100, 'disp': 1, 'eps': 1e-8})

    # print(history)
    print("---------------------------------------------------------------------------------------------")

    x_new = result.x
    print("result", x_new)
    # # update simulation with minimized positions and box vectors
    positions_arr = np.empty([n, 3])
    for i in range(int(n)):
        positions_arr[i][:] = x_new[i * 3:i * 3 + 3]
    simulation.context.setPositions(positions_arr)

    # convert result to box vector
    box_parameter_new = [x_new[n * 3], x_new[n * 3 + 1], x_new[n * 3 + 2], x_new[n * 3 + 3], x_new[n * 3 + 4], x_new[n * 3 + 5]]
    box_vectors_new = para2matrix(box_parameter_new, radians=False, format="lower")
    a = np.array([box_vectors_new[0][0], 0, 0])
    b = np.array([box_vectors_new[1][0], box_vectors_new[1][1], 0])
    c = np.array([box_vectors_new[2][0], box_vectors_new[2][1], box_vectors_new[2][2]])
    simulation.context.setPeriodicBoxVectors(a, b, c)

    min_state = simulation.context.getState(getEnergy=True, getPositions=True, getForces=True)
    min_potential = min_state.getPotentialEnergy()
    simulation.saveState('data/final_states/' + cod_id + '_final.xml')
    print('Final Energy = ' + str(min_potential))

    simulation.step(1)

    initial = mdtraj.load_pdb('data/PDB_supercell/' + cod_id + '_supercell.pdb')
    final = mdtraj.load_pdb('data/minimized_PDB_supercell/' + cod_id + '.pdb')
    rmsd = mdtraj.rmsd(initial, final)
    data.append(
        {
            'COD ID': cod_id,
            'RMSD': rmsd,
            'Original Energy': orig_potential,
            'Minimized Energy (OpenMM)': mid_potential,
            'Minimized Energy (Cell Minimization)': min_potential,
            'Original Box Vectors': A,
            'Minimized Box Vectors': np.array([a, b, c]),
            'Original Box parameters': box_parameter,
            'Minimized Box parameter': box_parameter_new,

        })
    with open('data/rmsd_values.txt', 'a') as f:
        f.write('%s\t%s\n' % (cod_id, rmsd[0]))
#except Exception as e:
#    logging.error('Generic error with ID %s' % cod_id)
#    logging.error(e)
#    continue



try:
    d = pd.DataFrame(data)
    d.to_csv('data/minimization_results.csv')
    d.to_pickle('data/minimization_results.pkl')
except Exception as e:
    logging.error('Error with save of results data')


